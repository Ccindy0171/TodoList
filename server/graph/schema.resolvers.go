package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"fmt"
	"server/graph/database"
	"server/graph/helpers"
	"server/graph/model"
	"strings"
	"time"

	"github.com/google/uuid"
	surrealdb "github.com/surrealdb/surrealdb.go"
)

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.TodoInput) (*model.TodoOutput, error) {
	id := uuid.New().String()
	now := time.Now()

	fmt.Printf("\n? CREATING todo with title: %s\n", input.Title)

	// Build the create query
	createQuery := fmt.Sprintf("CREATE todo SET id = '%s', title = '%s', updatedAt = <datetime>'%s', dueDate = <datetime>'%s'",
		id,
		helpers.EscapeString(input.Title),
		now.Format(time.RFC3339),
		input.DueDate.Format(time.RFC3339))

	// Set completed field - default to false if not provided
	if input.Completed != nil && *input.Completed {
		createQuery += ", completed = true"
	} else {
		createQuery += ", completed = false"
	}

	// Add createdAt
	createQuery += fmt.Sprintf(", createdAt = <datetime>'%s'", now.Format(time.RFC3339))

	// Add optional fields
	if input.Description != nil && *input.Description != "" {
		createQuery += fmt.Sprintf(", description = '%s'", helpers.EscapeString(*input.Description))
	}

	// Handle both categoryId and categoryIds for backward compatibility
	if input.CategoryIds != nil && len(input.CategoryIds) > 0 {
		// Use the first category as the primary categoryId for backward compatibility
		categoryID := input.CategoryIds[0]
		createQuery += fmt.Sprintf(", categoryId = '%s'", helpers.EscapeString(categoryID))

		// Store the full list of category IDs
		createQuery += fmt.Sprintf(", categoryIds = %s", helpers.FormatCategoryIdsArray(input.CategoryIds))
	} else if input.CategoryID != nil && *input.CategoryID != "" {
		// Legacy support for single categoryId
		createQuery += fmt.Sprintf(", categoryId = '%s'", helpers.EscapeString(*input.CategoryID))
		createQuery += fmt.Sprintf(", categoryIds = ['%s']", helpers.EscapeString(*input.CategoryID))
	} else {
		// Explicitly set categoryId and categoryIds to NULL if not provided
		createQuery += ", categoryId = NULL, categoryIds = []"
	}

	if input.Location != nil && *input.Location != "" {
		createQuery += fmt.Sprintf(", location = '%s'", helpers.EscapeString(*input.Location))
	}

	if input.Priority != nil {
		createQuery += fmt.Sprintf(", priority = %d", *input.Priority)
	}

	if input.Tags != nil && len(input.Tags) > 0 {
		tagsStr := "["
		for i, tag := range input.Tags {
			if i > 0 {
				tagsStr += ", "
			}
			tagsStr += fmt.Sprintf("'%s'", helpers.EscapeString(tag))
		}
		tagsStr += "]"
		createQuery += fmt.Sprintf(", tags = %s", tagsStr)
	} else {
		createQuery += ", tags = []"
	}

	// Debug info before executing query
	fmt.Printf("? Executing query: %s\n", createQuery)

	result, err := database.DB.Query(createQuery, nil)
	if err != nil {
		fmt.Printf("? Failed to create todo: %v\n", err)
		return nil, fmt.Errorf("failed to create todo: %v", err)
	}

	todos, err := surrealdb.SmartUnmarshal[[]*model.Todo](result, nil)
	if err != nil {
		fmt.Printf("? Failed to unmarshal created todo: %v\n", err)
		return nil, fmt.Errorf("failed to unmarshal created todo: %v", err)
	}

	if len(todos) == 0 {
		fmt.Printf("? No todo returned from creation query\n")
		return nil, fmt.Errorf("no todo returned from creation query")
	}

	todo := todos[0]
	fmt.Printf("? Todo created successfully: %+v\n", todo)

	// Build output with categories
	todoOutput := &model.TodoOutput{
		ID:          todo.ID,
		Title:       todo.Title,
		Description: todo.Description,
		Completed:   todo.Completed,
		DueDate:     todo.DueDate,
		Location:    todo.Location,
		Priority:    todo.Priority,
		Tags:        todo.Tags,
		UpdatedAt:   todo.UpdatedAt,
		Categories:  []*model.Category{},
	}

	// Fetch categories based on categoryIds first
	categoryIds := helpers.SafeCategoryIds(todo.CategoryIds)
	if len(categoryIds) > 0 {
		// Fetch all categories in one query for better performance
		formattedCategoryIdsArray := helpers.FormatCategoryIdsArray(categoryIds)
		catQuery := fmt.Sprintf("SELECT * FROM category WHERE id IN %s", formattedCategoryIdsArray)

		fmt.Printf("? Fetching categories with query: %s\n", catQuery)
		catResult, err := database.DB.Query(catQuery, nil)
		if err != nil {
			fmt.Printf("? Failed to fetch categories: %v\n", err)
			return nil, fmt.Errorf("failed to fetch categories: %v", err)
		}

		categories, err := surrealdb.SmartUnmarshal[[]*model.Category](catResult, nil)
		if err != nil {
			fmt.Printf("? Failed to unmarshal categories: %v\n", err)
			return nil, fmt.Errorf("failed to unmarshal categories: %v", err)
		}

		if len(categories) > 0 {
			todoOutput.Categories = categories

			// Set the primary category (first one) for backward compatibility
			if len(categories) > 0 {
				todoOutput.Category = categories[0]
			}

			fmt.Printf("? Found %d categories for todo\n", len(categories))
		}
	} else if todo.CategoryID != nil && *todo.CategoryID != "" {
		// Legacy support: fetch single category
		fmt.Printf("? Fetching category with ID: %s\n", *todo.CategoryID)
		catResult, err := database.DB.Query("SELECT * FROM category WHERE id = $id", map[string]interface{}{
			"id": *todo.CategoryID,
		})
		if err != nil {
			fmt.Printf("? Failed to fetch category: %v\n", err)
			return nil, fmt.Errorf("failed to fetch category: %v", err)
		}

		categories, err := surrealdb.SmartUnmarshal[[]*model.Category](catResult, nil)
		if err != nil {
			fmt.Printf("? Failed to unmarshal category: %v\n", err)
			return nil, fmt.Errorf("failed to unmarshal category: %v", err)
		}

		if len(categories) > 0 {
			todoOutput.Category = categories[0]
			todoOutput.Categories = categories
			fmt.Printf("? Found category: %s\n", categories[0].Name)
		} else {
			fmt.Printf("?? No category found with ID: %s\n", *todo.CategoryID)
		}
	} else {
		fmt.Printf("?? No category ID provided for this todo\n")
	}

	return todoOutput, nil
}

// UpdateTodo is the resolver for the updateTodo field.
func (r *mutationResolver) UpdateTodo(ctx context.Context, id string, input model.TodoInput) (*model.TodoOutput, error) {
	now := time.Now()

	fmt.Printf("? UPDATE todo with id: %s\n", id)

	// Update query for the todo
	updateQuery := fmt.Sprintf("UPDATE %s SET title = '%s', updatedAt = <datetime>'%s'",
		id, helpers.EscapeString(input.Title), now.Format(time.RFC3339))

	// Add optional fields for update
	if input.Description != nil {
		updateQuery += fmt.Sprintf(", description = '%s'", helpers.EscapeString(*input.Description))
	}

	// Handle the completed field
	if input.Completed != nil {
		updateQuery += fmt.Sprintf(", completed = %v", *input.Completed)
	}

	// Handle both categoryId and categoryIds for backward compatibility
	if input.CategoryIds != nil && len(input.CategoryIds) > 0 {
		// Use the first category as the primary categoryId for backward compatibility
		categoryID := input.CategoryIds[0]
		updateQuery += fmt.Sprintf(", categoryId = '%s'", helpers.EscapeString(categoryID))

		// Store the full list of category IDs
		updateQuery += fmt.Sprintf(", categoryIds = %s", helpers.FormatCategoryIdsArray(input.CategoryIds))
	} else if input.CategoryID != nil {
		// Legacy support for single categoryId
		if *input.CategoryID == "" {
			// Empty string means remove category
			updateQuery += ", categoryId = NULL, categoryIds = []"
		} else {
			updateQuery += fmt.Sprintf(", categoryId = '%s'", helpers.EscapeString(*input.CategoryID))
			updateQuery += fmt.Sprintf(", categoryIds = ['%s']", helpers.EscapeString(*input.CategoryID))
		}
	}

	if input.DueDate != (time.Time{}) {
		updateQuery += fmt.Sprintf(", dueDate = <datetime>'%s'", input.DueDate.Format(time.RFC3339))
	}

	if input.Location != nil {
		updateQuery += fmt.Sprintf(", location = '%s'", helpers.EscapeString(*input.Location))
	}

	if input.Priority != nil {
		updateQuery += fmt.Sprintf(", priority = %d", *input.Priority)
	}

	if input.Tags != nil {
		if len(input.Tags) > 0 {
			tagsStr := "["
			for i, tag := range input.Tags {
				if i > 0 {
					tagsStr += ", "
				}
				tagsStr += fmt.Sprintf("'%s'", helpers.EscapeString(tag))
			}
			tagsStr += "]"
			updateQuery += fmt.Sprintf(", tags = %s", tagsStr)
		} else {
			updateQuery += ", tags = []"
		}
	}

	fmt.Printf("? Executing query: %s\n", updateQuery)
	result, err := database.DB.Query(updateQuery, nil)
	if err != nil {
		fmt.Printf("? Failed to update todo: %v\n", err)
		return nil, fmt.Errorf("failed to update todo: %v", err)
	}

	updatedTodos, err := surrealdb.SmartUnmarshal[[]*model.Todo](result, nil)
	if err != nil {
		fmt.Printf("? Failed to unmarshal updated todo: %v\n", err)
		return nil, fmt.Errorf("failed to unmarshal updated todo: %v", err)
	}

	if len(updatedTodos) == 0 {
		fmt.Printf("? No todo returned from update query\n")
		return nil, fmt.Errorf("no todo returned from update query")
	}

	todo := updatedTodos[0]
	fmt.Printf("? Todo updated successfully: %+v\n", todo)

	// Build output with categories
	todoOutput := &model.TodoOutput{
		ID:          todo.ID,
		Title:       todo.Title,
		Description: todo.Description,
		Completed:   todo.Completed,
		DueDate:     todo.DueDate,
		Location:    todo.Location,
		Priority:    todo.Priority,
		Tags:        todo.Tags,
		UpdatedAt:   todo.UpdatedAt,
		Categories:  []*model.Category{},
	}

	// Fetch categories based on categoryIds first
	categoryIds := helpers.SafeCategoryIds(todo.CategoryIds)
	if len(categoryIds) > 0 {
		// Fetch all categories in one query for better performance
		formattedCategoryIdsArray := helpers.FormatCategoryIdsArray(categoryIds)
		catQuery := fmt.Sprintf("SELECT * FROM category WHERE id IN %s", formattedCategoryIdsArray)

		fmt.Printf("? Fetching categories with query: %s\n", catQuery)
		catResult, err := database.DB.Query(catQuery, nil)
		if err != nil {
			fmt.Printf("? Failed to fetch categories: %v\n", err)
			return nil, fmt.Errorf("failed to fetch categories: %v", err)
		}

		categories, err := surrealdb.SmartUnmarshal[[]*model.Category](catResult, nil)
		if err != nil {
			fmt.Printf("? Failed to unmarshal categories: %v\n", err)
			return nil, fmt.Errorf("failed to unmarshal categories: %v", err)
		}

		if len(categories) > 0 {
			todoOutput.Categories = categories

			// Set the primary category (first one) for backward compatibility
			if len(categories) > 0 {
				todoOutput.Category = categories[0]
			}

			fmt.Printf("? Found %d categories for todo\n", len(categories))
		}
	} else if todo.CategoryID != nil && *todo.CategoryID != "" {
		// Legacy support: fetch single category
		fmt.Printf("? Fetching category for todo: %s\n", todo.ID)
		catResult, err := database.DB.Query("SELECT * FROM category WHERE id = $id", map[string]interface{}{
			"id": *todo.CategoryID,
		})
		if err != nil {
			fmt.Printf("? Failed to fetch category: %v\n", err)
			return nil, fmt.Errorf("failed to fetch category: %v", err)
		}

		categories, err := surrealdb.SmartUnmarshal[[]*model.Category](catResult, nil)
		if err != nil {
			fmt.Printf("? Failed to unmarshal category: %v\n", err)
			return nil, fmt.Errorf("failed to unmarshal category: %v", err)
		}

		if len(categories) > 0 {
			todoOutput.Category = categories[0]
			todoOutput.Categories = []*model.Category{categories[0]}
			fmt.Printf("? Found category: %s\n", categories[0].Name)
		} else {
			fmt.Printf("?? No category found with ID: %s\n", *todo.CategoryID)
		}
	} else {
		fmt.Printf("?? No categories for this todo\n")
	}

	return todoOutput, nil
}

// ToggleTodo is the resolver for the toggleTodo field.
func (r *mutationResolver) ToggleTodo(ctx context.Context, id string) (*model.TodoOutput, error) {
	fmt.Printf("? ToggleTodo called for id: %s\n", id)

	// First, get the current todo to check its completed status
	result, err := database.DB.Query(
		`SELECT * FROM $todo_id;`,
		map[string]interface{}{
			"todo_id": id,
		},
	)
	if err != nil {
		fmt.Printf("? Error fetching todo: %v\n", err)
		return nil, err
	}

	todos, err := surrealdb.SmartUnmarshal[[]model.Todo](result, nil)
	if err != nil {
		fmt.Printf("? Error unmarshalling todo: %v\n", err)
		return nil, err
	}

	if len(todos) == 0 {
		fmt.Printf("? Todo not found with id: %s\n", id)
		return nil, fmt.Errorf("todo not found")
	}

	// Get the current completed state and invert it
	currentCompleted := todos[0].Completed
	newCompleted := !currentCompleted
	now := time.Now().Format(time.RFC3339)

	// Build the UPDATE query
	updateQuery := fmt.Sprintf("UPDATE %s SET completed = %v, updatedAt = <datetime>'%s'",
		id,
		newCompleted,
		now)

	fmt.Printf("? Executing update query: %s\n", updateQuery)

	// Execute the UPDATE query
	updateResult, err := database.DB.Query(updateQuery, nil)
	if err != nil {
		fmt.Printf("? Failed to toggle todo: %v\n", err)
		return nil, fmt.Errorf("failed to toggle todo: %v", err)
	}

	updatedTodos, err := surrealdb.SmartUnmarshal[[]*model.Todo](updateResult, nil)
	if err != nil {
		fmt.Printf("? Failed to unmarshal updated todo: %v\n", err)
		return nil, fmt.Errorf("failed to unmarshal updated todo: %v", err)
	}

	if len(updatedTodos) == 0 {
		fmt.Printf("? No todo returned from update query\n")
		return nil, fmt.Errorf("no todo returned from update query")
	}

	todo := updatedTodos[0]
	fmt.Printf("? Todo toggled successfully, completed: %v\n", todo.Completed)

	// Build output with categories
	todoOutput := &model.TodoOutput{
		ID:          todo.ID,
		Title:       todo.Title,
		Description: todo.Description,
		Completed:   todo.Completed,
		DueDate:     todo.DueDate,
		Location:    todo.Location,
		Priority:    todo.Priority,
		Tags:        todo.Tags,
		UpdatedAt:   todo.UpdatedAt,
		Categories:  []*model.Category{},
	}

	// Fetch categories based on categoryIds first
	categoryIds := helpers.SafeCategoryIds(todo.CategoryIds)
	if len(categoryIds) > 0 {
		// Fetch all categories in one query for better performance
		formattedCategoryIdsArray := helpers.FormatCategoryIdsArray(categoryIds)
		catQuery := fmt.Sprintf("SELECT * FROM category WHERE id IN %s", formattedCategoryIdsArray)

		fmt.Printf("? Fetching categories with query: %s\n", catQuery)
		catResult, err := database.DB.Query(catQuery, nil)
		if err != nil {
			fmt.Printf("? Failed to fetch categories: %v\n", err)
			return nil, fmt.Errorf("failed to fetch categories: %v", err)
		}

		categories, err := surrealdb.SmartUnmarshal[[]*model.Category](catResult, nil)
		if err != nil {
			fmt.Printf("? Failed to unmarshal categories: %v\n", err)
			return nil, fmt.Errorf("failed to unmarshal categories: %v", err)
		}

		if len(categories) > 0 {
			todoOutput.Categories = categories

			// Set the primary category (first one) for backward compatibility
			if len(categories) > 0 {
				todoOutput.Category = categories[0]
			}

			fmt.Printf("? Found %d categories for todo\n", len(categories))
		}
	} else if todo.CategoryID != nil && *todo.CategoryID != "" {
		// Legacy support: fetch single category
		fmt.Printf("? Fetching category for todo: %s\n", todo.ID)
		catResult, err := database.DB.Query("SELECT * FROM category WHERE id = $id", map[string]interface{}{
			"id": *todo.CategoryID,
		})
		if err != nil {
			fmt.Printf("? Failed to fetch category: %v\n", err)
			return nil, fmt.Errorf("failed to fetch category: %v", err)
		}

		categories, err := surrealdb.SmartUnmarshal[[]*model.Category](catResult, nil)
		if err != nil {
			fmt.Printf("? Failed to unmarshal category: %v\n", err)
			return nil, fmt.Errorf("failed to unmarshal category: %v", err)
		}

		if len(categories) > 0 {
			todoOutput.Category = categories[0]
			todoOutput.Categories = []*model.Category{categories[0]}
			fmt.Printf("? Found category: %s\n", categories[0].Name)
		}
	} else {
		fmt.Printf("?? No categories for this todo\n")
	}

	return todoOutput, nil
}

// DeleteTodo is the resolver for the deleteTodo field.
func (r *mutationResolver) DeleteTodo(ctx context.Context, id string) (bool, error) {
	_, err := database.DB.Delete(id)
	if err != nil {
		return false, fmt.Errorf("failed to delete todo: %v", err)
	}
	return true, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.CategoryInput) (*model.Category, error) {
	id := uuid.New().String()
	now := time.Now()

	category := &model.Category{
		ID:        id,
		Name:      input.Name,
		Color:     input.Color,
		CreatedAt: now,
		UpdatedAt: now,
	}

	_, err := database.DB.Create("category", category)
	if err != nil {
		return nil, fmt.Errorf("failed to create category: %v", err)
	}

	return category, nil
}

// UpdateCategory is the resolver for the updateCategory field.
func (r *mutationResolver) UpdateCategory(ctx context.Context, id string, input model.CategoryInput) (*model.Category, error) {
	fmt.Printf("? Updating category with ID: %s\n", id)

	// Build the update query
	updateQuery := fmt.Sprintf("UPDATE %s SET name = '%s', color = '%s', updatedAt = <datetime>'%s'",
		id,
		input.Name,
		input.Color,
		time.Now().Format(time.RFC3339))

	// Debug info before executing query
	fmt.Printf("? Executing update query: %s\n", updateQuery)

	result, err := database.DB.Query(updateQuery, nil)
	if err != nil {
		fmt.Printf("? Failed to update category: %v\n", err)
		return nil, fmt.Errorf("failed to update category: %v", err)
	}

	updatedCategories, err := surrealdb.SmartUnmarshal[[]*model.Category](result, nil)
	if err != nil {
		fmt.Printf("? Failed to unmarshal updated category: %v\n", err)
		return nil, fmt.Errorf("failed to unmarshal updated category: %v", err)
	}

	if len(updatedCategories) == 0 {
		fmt.Printf("? No category returned from update query\n")
		return nil, fmt.Errorf("no category returned from update query")
	}

	category := updatedCategories[0]
	fmt.Printf("? Category updated successfully: %+v\n", category)

	return category, nil
}

// DeleteCategory is the resolver for the deleteCategory field.
func (r *mutationResolver) DeleteCategory(ctx context.Context, id string) (bool, error) {
	// First, check if the category exists
	catResult, err := database.DB.Query("SELECT * FROM category WHERE id = $id", map[string]interface{}{
		"id": id,
	})
	if err != nil {
		return false, fmt.Errorf("failed to fetch category: %v", err)
	}

	categories, err := surrealdb.SmartUnmarshal[[]*model.Category](catResult, nil)
	if err != nil {
		return false, fmt.Errorf("failed to unmarshal category: %v", err)
	}

	if len(categories) == 0 {
		return false, fmt.Errorf("category not found with id: %s", id)
	}

	// Get the category name for logging
	categoryName := categories[0].Name
	fmt.Printf("? Deleting category: %s (ID: %s)\n", categoryName, id)

	// Find all todos that reference this category (either in categoryId or categoryIds)
	todosQuery := fmt.Sprintf("SELECT * FROM todo WHERE categoryId = '%s' OR '%s' IN categoryIds", id, id)
	todosResult, err := database.DB.Query(todosQuery, nil)
	if err != nil {
		return false, fmt.Errorf("failed to fetch todos for category: %v", err)
	}

	todos, err := surrealdb.SmartUnmarshal[[]*model.Todo](todosResult, nil)
	if err != nil {
		return false, fmt.Errorf("failed to unmarshal todos: %v", err)
	}

	fmt.Printf("? Found %d todos referencing category %s\n", len(todos), id)

	// Update all todos to remove the category reference
	if len(todos) > 0 {
		// For each todo, we need to update it individually to handle both single and multiple categories
		for _, todo := range todos {
			todoId := todo.ID

			if todo.CategoryID != nil && *todo.CategoryID == id {
				// This todo has the deleted category as its primary category

				if len(todo.CategoryIds) > 1 {
					// It has other categories too, use the next one as primary
					newCategoryIds := []string{}
					newPrimaryId := ""

					for _, catId := range todo.CategoryIds {
						if catId != id {
							newCategoryIds = append(newCategoryIds, catId)
							if newPrimaryId == "" {
								newPrimaryId = catId
							}
						}
					}

					// Update with new primary and categoryIds
					categoryIdsStr := fmt.Sprintf("['%s']", strings.Join(newCategoryIds, "','"))
					updateQuery := fmt.Sprintf("UPDATE %s SET categoryId = '%s', categoryIds = %s, updatedAt = <datetime>'%s'",
						todoId,
						newPrimaryId,
						categoryIdsStr,
						time.Now().Format(time.RFC3339))

					fmt.Printf("? Updating todo %s to use new primary category: %s\n", todoId, newPrimaryId)
					_, err := database.DB.Query(updateQuery, nil)
					if err != nil {
						return false, fmt.Errorf("failed to update todo %s: %v", todoId, err)
					}
				} else {
					// It only had this category, remove the category completely
					updateQuery := fmt.Sprintf("UPDATE %s SET categoryId = NULL, categoryIds = [], updatedAt = <datetime>'%s'",
						todoId,
						time.Now().Format(time.RFC3339))

					fmt.Printf("? Removing all categories from todo %s\n", todoId)
					_, err := database.DB.Query(updateQuery, nil)
					if err != nil {
						return false, fmt.Errorf("failed to update todo %s: %v", todoId, err)
					}
				}
			} else if len(todo.CategoryIds) > 0 {
				// This todo has the category in its categoryIds but not as primary
				// Just update the categoryIds array
				newCategoryIds := []string{}

				for _, catId := range todo.CategoryIds {
					if catId != id {
						newCategoryIds = append(newCategoryIds, catId)
					}
				}

				// Use an empty array if no categories left
				categoryIdsStr := "[]"
				if len(newCategoryIds) > 0 {
					categoryIdsStr = fmt.Sprintf("['%s']", strings.Join(newCategoryIds, "','"))
				}

				updateQuery := fmt.Sprintf("UPDATE %s SET categoryIds = %s, updatedAt = <datetime>'%s'",
					todoId,
					categoryIdsStr,
					time.Now().Format(time.RFC3339))

				fmt.Printf("? Removing category %s from categoryIds for todo %s\n", id, todoId)
				_, err := database.DB.Query(updateQuery, nil)
				if err != nil {
					return false, fmt.Errorf("failed to update todo %s: %v", todoId, err)
				}
			}
		}

		fmt.Printf("? Successfully updated %d todos to remove category references\n", len(todos))
	}

	// Now delete the category
	_, err = database.DB.Delete(id)
	if err != nil {
		return false, fmt.Errorf("failed to delete category: %v", err)
	}

	fmt.Printf("? Successfully deleted category: %s\n", categoryName)
	return true, nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context, filter *model.TodoFilter) ([]*model.TodoOutput, error) {
	fmt.Printf("? Querying todos with filter: %+v\n", filter)

	// Start building the query
	query := "SELECT * FROM todo"

	// Track if we're using the noCategoryOnly filter
	var noCategoryFilter bool

	// Build conditions based on filter
	var conditions []string
	if filter != nil {
		if filter.Completed != nil {
			completedStr := "false"
			if *filter.Completed {
				completedStr = "true"
			}
			conditions = append(conditions, fmt.Sprintf("completed = %s", completedStr))
			fmt.Printf("? Adding completed filter: %v\n", *filter.Completed)
		}

		// Handle categoryIds filter (multiple categories)
		if filter.CategoryIds != nil && len(filter.CategoryIds) > 0 {
			categoryQueryConditions := []string{}
			for _, catID := range filter.CategoryIds {
				escapedCatID := helpers.EscapeString(catID)
				// Match if the category is the primary categoryId OR is in the categoryIds array
				categoryQueryConditions = append(categoryQueryConditions, 
					fmt.Sprintf("(categoryId = '%s' OR '%s' IN categoryIds)", escapedCatID, escapedCatID))
			}
			// A todo matches if ANY of the filter category conditions are met
			if len(categoryQueryConditions) > 0 {
				conditions = append(conditions, fmt.Sprintf("(%s)", strings.Join(categoryQueryConditions, " OR ")))
				fmt.Printf("? Adding categoryIds filter for %d categories\n", len(filter.CategoryIds))
			}
		} else if filter.CategoryID != nil && *filter.CategoryID != "" { // Handle single categoryId filter (legacy)
			if strings.ToLower(*filter.CategoryID) == "none" {
				noCategoryFilter = true
				fmt.Printf("? Using special 'none' category filter\n")
			} else {
				escapedCatID := helpers.EscapeString(*filter.CategoryID)
				// CORRECTED: Was categoryIds[WHERE $this = '%s'] in user's version
				conditions = append(conditions, fmt.Sprintf("(categoryId = '%s' OR '%s' IN categoryIds)",
					escapedCatID, escapedCatID))
				fmt.Printf("? Adding categoryId filter: %s\n", *filter.CategoryID)
			}
		}

		// Handle explicit noCategoryOnly filter
		if filter.NoCategoryOnly != nil && *filter.NoCategoryOnly {
			noCategoryFilter = true
			// CORRECTED: Removed extra backslash from \'\' to \' 
			conditions = append(conditions, "((categoryId IS NULL OR categoryId = '') AND (categoryIds IS NULL OR array::len(categoryIds) = 0))")
			fmt.Printf("? Using noCategoryOnly filter\n")
		}

		if filter.StartDate != nil {
			conditions = append(conditions, fmt.Sprintf("dueDate >= <datetime>'%s'", filter.StartDate.Format(time.RFC3339)))
			fmt.Printf("? Adding startDate filter: %s\n", filter.StartDate.Format(time.RFC3339))
		}

		if filter.EndDate != nil {
			conditions = append(conditions, fmt.Sprintf("dueDate <= <datetime>'%s'", filter.EndDate.Format(time.RFC3339)))
			fmt.Printf("? Adding endDate filter: %s\n", filter.EndDate.Format(time.RFC3339))
		}

		if filter.UpdatedBefore != nil {
			conditions = append(conditions, fmt.Sprintf("updatedAt <= <datetime>'%s'", filter.UpdatedBefore.Format(time.RFC3339)))
			fmt.Printf("? Adding updatedBefore filter: %s\n", filter.UpdatedBefore.Format(time.RFC3339))
		}

		if filter.UpdatedAfter != nil {
			conditions = append(conditions, fmt.Sprintf("updatedAt >= <datetime>'%s'", filter.UpdatedAfter.Format(time.RFC3339)))
			fmt.Printf("? Adding updatedAfter filter: %s\n", filter.UpdatedAfter.Format(time.RFC3339))
		}

		if filter.Priority != nil {
			conditions = append(conditions, fmt.Sprintf("priority = %d", *filter.Priority))
			fmt.Printf("? Adding priority filter: %d\n", *filter.Priority)
		}

		if filter.Tags != nil && len(filter.Tags) > 0 {
			tagConditions := []string{}
			for _, tag := range filter.Tags {
				tagConditions = append(tagConditions, fmt.Sprintf("'%s' IN tags", tag))
			}
			conditions = append(conditions, fmt.Sprintf("(%s)", strings.Join(tagConditions, " OR ")))
			fmt.Printf("? Adding tags filter: %v\n", filter.Tags)
		}
	}

	if len(conditions) > 0 {
		query += " WHERE " + strings.Join(conditions, " AND ")
	}

	fmt.Printf("? Executing SurrealDB query: %s\n", query)

	result, err := database.DB.Query(query, map[string]interface{}{})
	if err != nil {
		fmt.Printf("? Error fetching todos: %v\n", err)
		return nil, fmt.Errorf("failed to fetch todos: %v", err)
	}

	todos, err := surrealdb.SmartUnmarshal[[]*model.Todo](result, nil)
	if err != nil {
		fmt.Printf("? Error unmarshalling todos: %v\n", err)
		return nil, fmt.Errorf("failed to unmarshal todos: %v", err)
	}

	fmt.Printf("? Found %d todos\n", len(todos))

	// Log todos for debugging
	for _, todo := range todos {
		fmt.Printf("? Todo: ID=%s, Title=%s, CategoryID=%v, CategoryIds=%v\n",
			todo.ID, todo.Title, todo.CategoryID, todo.CategoryIds)
	}

	// Convert todos to todo outputs and fetch categories
	outputs := make([]*model.TodoOutput, 0, len(todos))
	for _, todo := range todos {
		// Special handling for noCategoryOnly filter
		if noCategoryFilter {
			// Skip if it has a valid category ID or categoryIds
			if (todo.CategoryID != nil && *todo.CategoryID != "") || len(todo.CategoryIds) > 0 {
				continue
			}
		}

		output := &model.TodoOutput{
			ID:          todo.ID,
			Title:       todo.Title,
			Description: todo.Description,
			Completed:   todo.Completed,
			DueDate:     todo.DueDate,
			Location:    todo.Location,
			Priority:    todo.Priority,
			Tags:        todo.Tags,
			UpdatedAt:   todo.UpdatedAt,
			Categories:  []*model.Category{},
		}

		// First try to fetch categories using categoryIds
		if len(todo.CategoryIds) > 0 {
			// Fetch all categories in one query for better performance
			formattedCategoryIdsArray := helpers.FormatCategoryIdsArray(todo.CategoryIds)
			catQuery := fmt.Sprintf("SELECT * FROM category WHERE id IN %s", formattedCategoryIdsArray)

			fmt.Printf("? Fetching categories with query: %s\n", catQuery)
			catResult, err := database.DB.Query(catQuery, nil)
			if err != nil {
				fmt.Printf("? Error fetching categories: %v\n", err)
				return nil, fmt.Errorf("failed to fetch categories: %v", err)
			}

			categories, err := surrealdb.SmartUnmarshal[[]*model.Category](catResult, nil)
			if err != nil {
				fmt.Printf("? Error unmarshalling categories: %v\n", err)
				return nil, fmt.Errorf("failed to unmarshal categories: %v", err)
			}

			if len(categories) > 0 {
				output.Categories = categories

				// Set the primary category (first one) for backward compatibility
				if len(categories) > 0 {
					output.Category = categories[0]
				}
				fmt.Printf("? Found %d categories for todo %s\n", len(categories), todo.ID)
			}
		} else if todo.CategoryID != nil && *todo.CategoryID != "" {
			// Legacy support: fetch single category
			fmt.Printf("? Fetching category for todo %s with categoryId %s\n", todo.ID, *todo.CategoryID)
			catResult, err := database.DB.Query("SELECT * FROM category WHERE id = $id", map[string]interface{}{
				"id": *todo.CategoryID,
			})
			if err != nil {
				fmt.Printf("? Error fetching category: %v\n", err)
				return nil, fmt.Errorf("failed to fetch category: %v", err)
			}

			categories, err := surrealdb.SmartUnmarshal[[]*model.Category](catResult, nil)
			if err != nil {
				fmt.Printf("? Error unmarshalling category: %v\n", err)
				return nil, fmt.Errorf("failed to unmarshal category: %v", err)
			}

			if len(categories) > 0 {
				output.Category = categories[0]
				output.Categories = []*model.Category{categories[0]}
				fmt.Printf("? Found category for todo %s: %s\n", todo.ID, categories[0].Name)
			} else {
				fmt.Printf("?? No category found for todo %s with categoryId %s\n", todo.ID, *todo.CategoryID)
			}
		} else {
			fmt.Printf("?? Todo %s has no category\n", todo.ID)
		}

		outputs = append(outputs, output)
	}

	fmt.Printf("? Returning %d todo outputs\n", len(outputs))
	return outputs, nil
}

// Todo is the resolver for the todo field.
func (r *queryResolver) Todo(ctx context.Context, id string) (*model.TodoOutput, error) {
	result, err := database.DB.Query("SELECT * FROM todo WHERE id = $id", map[string]interface{}{
		"id": id,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch todo: %v", err)
	}

	todos, err := surrealdb.SmartUnmarshal[[]*model.Todo](result, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal todo: %v", err)
	}

	if len(todos) == 0 {
		return nil, nil
	}

	todo := todos[0]
	output := &model.TodoOutput{
		ID:          todo.ID,
		Title:       todo.Title,
		Description: todo.Description,
		Completed:   todo.Completed,
		DueDate:     todo.DueDate,
		Location:    todo.Location,
		Priority:    todo.Priority,
		Tags:        todo.Tags,
		UpdatedAt:   todo.UpdatedAt,
		Categories:  []*model.Category{},
	}

	// Fetch categories based on categoryIds first
	categoryIds := helpers.SafeCategoryIds(todo.CategoryIds)
	if len(categoryIds) > 0 {
		// Fetch all categories in one query for better performance
		formattedCategoryIdsArray := helpers.FormatCategoryIdsArray(categoryIds)
		catQuery := fmt.Sprintf("SELECT * FROM category WHERE id IN %s", formattedCategoryIdsArray)

		fmt.Printf("? Fetching categories with query: %s\n", catQuery)
		catResult, err := database.DB.Query(catQuery, nil)
		if err != nil {
			fmt.Printf("? Failed to fetch categories: %v\n", err)
			return nil, fmt.Errorf("failed to fetch categories: %v", err)
		}

		categories, err := surrealdb.SmartUnmarshal[[]*model.Category](catResult, nil)
		if err != nil {
			fmt.Printf("? Failed to unmarshal categories: %v\n", err)
			return nil, fmt.Errorf("failed to unmarshal categories: %v", err)
		}

		if len(categories) > 0 {
			output.Categories = categories

			// Set the primary category (first one) for backward compatibility
			output.Category = categories[0]
			fmt.Printf("? Found %d categories for todo\n", len(categories))
		}
	} else if todo.CategoryID != nil && *todo.CategoryID != "" {
		// Legacy support: fetch single category
		catResult, err := database.DB.Query("SELECT * FROM category WHERE id = $id", map[string]interface{}{
			"id": *todo.CategoryID,
		})
		if err != nil {
			return nil, fmt.Errorf("failed to fetch category: %v", err)
		}

		categories, err := surrealdb.SmartUnmarshal[[]*model.Category](catResult, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal category: %v", err)
		}

		if len(categories) > 0 {
			output.Category = categories[0]
			output.Categories = []*model.Category{categories[0]}
		}
	}

	return output, nil
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	result, err := database.DB.Query("SELECT * FROM category", map[string]interface{}{})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch categories: %v", err)
	}

	fmt.Println(result)

	categories, err := surrealdb.SmartUnmarshal[[]*model.Category](result, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal categories: %v", err)
	}

	return categories, nil
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, id string) (*model.Category, error) {
	result, err := database.DB.Query("SELECT * FROM category WHERE id = $id", map[string]interface{}{
		"id": id,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch category: %v", err)
	}

	categories, err := surrealdb.SmartUnmarshal[[]*model.Category](result, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal category: %v", err)
	}

	if len(categories) == 0 {
		return nil, nil
	}

	return categories[0], nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
